<html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover"><meta name="google-site-verification" content="cCHsgG9ktuCTgWgYfqCJql8AeR4gAne4DTZqztPoirE"><meta name="apple-itunes-app" content="app-id=987739104"><meta name="baidu-site-verification" content="qiK2a1kcFc"><meta name="360-site-verification" content="4c3c7d57d59f0e1a308462fbc7fd7e51"><meta name="sogou_site_verification" content="c49WUDZczQ"><title data-vue-meta="true">剖析 Vue.js 内部运行机制 - 染陌同学 - 掘金小册</title><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/manifest.6bf42775ff3ede98a73a.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/vendor.35e0b2c7b9da74dd2322.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/js/app.1d801972a0d11ad831f3.js" as="script"><link rel="preload" href="https://b-gold-cdn.xitu.io/v3/static/css/app.1b316b577700ef69a2d27840e1b6e001.css" as="style"><link rel="apple-touch-icon" sizes="180x180" href="https://b-gold-cdn.xitu.io/favicons/v2/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon-16x16.png"><link rel="manifest" href="https://b-gold-cdn.xitu.io/favicons/v2/manifest.json"><link rel="mask-icon" href="https://b-gold-cdn.xitu.io/favicons/v2/safari-pinned-tab.svg" color="#5bbad5"><link rel="shortcut icon" href="https://b-gold-cdn.xitu.io/favicons/v2/favicon.ico"><meta name="msapplication-config" content="https://b-gold-cdn.xitu.io/favicons/v2/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="search" title="掘金" href="https://b-gold-cdn.xitu.io/conf/search.xml" type="application/opensearchdescription+xml"><link rel="stylesheet" href="https://b-gold-cdn.xitu.io/ionicons/2.0.1/css/ionicons.min.css"><link rel="stylesheet" href="https://b-gold-cdn.xitu.io/asset/fw-icon/1.0.9/iconfont.css"><link href="https://b-gold-cdn.xitu.io/v3/static/css/app.1b316b577700ef69a2d27840e1b6e001.css" rel="stylesheet"><script async="" src="https://hm.baidu.com/hm.js?93bbd335a208870aa1f296bcd6842e5e"></script><script async="" src="//www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://assets.growingio.com/vds.js"></script><script type="text/javascript" charset="utf-8" async="" src="https://b-gold-cdn.xitu.io/v3/static/js/12.fbad00127b15eab47be6.js"></script><meta data-vmid="keywords" name="keywords" content="掘金,稀土,Vue.js,微信小程序,Kotlin,RxJava,React Native,Wireshark,敏捷开发,Bootstrap,OKHttp,正则表达式,WebGL,Webpack,Docker,MVVM" data-vue-meta="true"><meta data-vmid="description" name="description" content="掘金是一个帮助开发者成长的社区，是给开发者用的 Hacker News，给设计师用的 Designer News，和给产品经理用的 Medium。掘金的技术文章由稀土上聚集的技术大牛和极客共同编辑为你筛选出最优质的干货，其中包括：Android、iOS、前端、后端等方面的内容。用户每天都可以在这里找到技术世界的头条内容。与此同时，掘金内还有沸点、掘金翻译计划、线下活动、专栏文章等内容。即使你是 GitHub、StackOverflow、开源中国的用户，我们相信你也可以在这里有所收获。" data-vue-meta="true"><script type="text/javascript" charset="utf-8" async="" src="https://b-gold-cdn.xitu.io/v3/static/js/6.a62bf3ae38fb5b6d3c50.js"></script></head><body><div data-v-41acfafa="" data-v-decff8c4="" class="section-content"><div data-v-41acfafa="" class="section-page book-section-view"><div data-v-41acfafa="" class="entry-content article-content"><h1 class="heading" data-id="heading-0">数据状态更新时的差异 diff 及 patch 机制</h1>
<h2 class="heading" data-id="heading-1">数据更新视图</h2>
<p>之前讲到，在对 <code>model</code> 进行操作对时候，会触发对应 <code>Dep</code> 中的 <code>Watcher</code> 对象。<code>Watcher</code> 对象会调用对应的 <code>update</code> 来修改视图。最终是将新产生的 VNode 节点与老 VNode 进行一个 <code>patch</code> 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p>
<p>这一章就来介绍一下这个 <code>patch</code> 的过程，因为 <code>patch</code> 过程本身比较复杂，这一章的内容会比较多，但是不要害怕，我们逐块代码去看，一定可以理解。</p>
<h2 class="heading" data-id="heading-2">跨平台</h2>
<p>因为使用了 Virtual DOM 的原因，Vue.js具有了跨平台的能力，Virtual DOM 终归只是一些 JavaScript 对象罢了，那么最终是如何调用不同平台的 API 的呢？</p>
<p>这就需要依赖一层适配层了，将不同平台的 API 封装在内，以同样的接口对外提供。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">const</span> nodeOps = {
    setTextContent (text) {
        <span class="hljs-keyword">if</span> (platform === <span class="hljs-string">'weex'</span>) {
            node.parentNode.setAttr(<span class="hljs-string">'value'</span>, text);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (platform === <span class="hljs-string">'web'</span>) {
            node.textContent = text;
        }
    },
    parentNode () {
        <span class="hljs-comment">//......</span>
    },
    removeChild () {
        <span class="hljs-comment">//......</span>
    },
    nextSibling () {
        <span class="hljs-comment">//......</span>
    },
    insertBefore () {
        <span class="hljs-comment">//......</span>
    }
}
</code></pre><p>举个例子，现在我们有上述一个 <code>nodeOps</code> 对象做适配，根据 platform 区分不同平台来执行当前平台对应的API，而对外则是提供了一致的接口，供 Virtual DOM 来调用。</p>
<h2 class="heading" data-id="heading-3">一些API</h2>
<p>接下来我们来介绍其他的一些 API，这些API在下面 <code>patch</code> 的过程中会被用到，他们最终都会调用 <code>nodeOps</code> 中的相应函数来操作平台。</p>
<p><code>insert</code> 用来在 <code>parent</code> 这个父节点下插入一个子节点，如果指定了 <code>ref</code> 则插入到 <code>ref</code> 这个子节点前面。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span> (<span class="hljs-params">parent, elm, ref</span>) </span>{
    <span class="hljs-keyword">if</span> (parent) {
        <span class="hljs-keyword">if</span> (ref) {
            <span class="hljs-keyword">if</span> (ref.parentNode === parent) {
                nodeOps.insertBefore(parent, elm, ref);
            }
        } <span class="hljs-keyword">else</span> {
            nodeOps.appendChild(parent, elm)
        }
    }
}
</code></pre><p><code>createElm</code> 用来新建一个节点， <code>tag</code> 存在创建一个标签节点，否则创建一个文本节点。</p>
<pre><code class="hljs javascript" lang="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createElm</span> (<span class="hljs-params">vnode, parentElm, refElm</span>) </span>{
    <span class="hljs-keyword">if</span> (vnode.tag) {
        insert(parentElm, nodeOps.createElement(vnode.tag), refElm);
    } <span class="hljs-keyword">else</span> {
        insert(parentElm, nodeOps.createTextNode(vnode.text), refElm);
    }
}
</code></pre><p><code>addVnodes</code> 用来批量调用 <code>createElm</code> 新建节点。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addVnodes</span> (<span class="hljs-params">parentElm, refElm, vnodes, startIdx, endIdx</span>) </span>{
    <span class="hljs-keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], parentElm, refElm);
    }
}
</code></pre><p><code>removeNode</code> 用来移除一个节点。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNode</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-keyword">const</span> parent = nodeOps.parentNode(el);
    <span class="hljs-keyword">if</span> (parent) {
        nodeOps.removeChild(parent, el);
    }
}
</code></pre><p><code>removeVnodes</code> 会批量调用 <code>removeNode</code> 移除节点。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeVnodes</span> (<span class="hljs-params">parentElm, vnodes, startIdx, endIdx</span>) </span>{
    <span class="hljs-keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) {
        <span class="hljs-keyword">const</span> ch = vnodes[startIdx]
        <span class="hljs-keyword">if</span> (ch) {
            removeNode(ch.elm);
        }
    }
}
</code></pre><h2 class="heading" data-id="heading-4">patch</h2>
<p>首先说一下 <code>patch</code> 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 <code>patch</code> 的过程，我们需要将他们进行比对。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/28/1609be691ed64525?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="706" data-height="295" src="https://user-gold-cdn.xitu.io/2017/12/28/1609be691ed64525?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2017/12/28/1609be700a80c98a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="628" data-height="214" src="https://user-gold-cdn.xitu.io/2017/12/28/1609be700a80c98a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure>。<p></p>
<p>这张图中的相同颜色的方块中的节点会进行比对，比对得到「<strong>差异</strong>」后将这些「<strong>差异</strong>」更新到视图上。因为只进行同层级的比对，所以十分高效。</p>
<p><code>patch</code> 的过程相当复杂，我们先用简单的代码来看一下。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patch</span> (<span class="hljs-params">oldVnode, vnode, parentElm</span>) </span>{
    <span class="hljs-keyword">if</span> (!oldVnode) {
        addVnodes(parentElm, <span class="hljs-literal">null</span>, vnode, <span class="hljs-number">0</span>, vnode.length - <span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vnode) {
        removeVnodes(parentElm, oldVnode, <span class="hljs-number">0</span>, oldVnode.length - <span class="hljs-number">1</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (sameVnode(oldVNode, vnode)) {
            patchVnode(oldVNode, vnode);
        } <span class="hljs-keyword">else</span> {
            removeVnodes(parentElm, oldVnode, <span class="hljs-number">0</span>, oldVnode.length - <span class="hljs-number">1</span>);
            addVnodes(parentElm, <span class="hljs-literal">null</span>, vnode, <span class="hljs-number">0</span>, vnode.length - <span class="hljs-number">1</span>);
        }
    }
}
</code></pre><p>因为 <code>patch</code> 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。我们来逐步捋一下逻辑， <code>addVnodes</code> 、 <code>removeVnodes</code> 等函数后面会讲。</p>
<p>首先在 <code>oldVnode</code>（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 <code>addVnodes</code> 将这些节点批量添加到 <code>parentElm</code> 上。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (!oldVnode) {
    addVnodes(parentElm, <span class="hljs-literal">null</span>, vnode, <span class="hljs-number">0</span>, vnode.length - <span class="hljs-number">1</span>);
}
</code></pre><p>然后同理，在 <code>vnode</code>（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 <code>removeVnodes</code> 进行批量的节点删除即可。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vnode) {
    removeVnodes(parentElm, oldVnode, <span class="hljs-number">0</span>, oldVnode.length - <span class="hljs-number">1</span>);
}
</code></pre><p>最后一种情况，当 <code>oldVNode</code> 与 <code>vnode</code> 都存在的时候，需要判断它们是否属于 <code>sameVnode</code>（相同的节点）。如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (sameVnode(oldVNode, vnode)) {
    patchVnode(oldVNode, vnode);
} <span class="hljs-keyword">else</span> {
    removeVnodes(parentElm, oldVnode, <span class="hljs-number">0</span>, oldVnode.length - <span class="hljs-number">1</span>);
    addVnodes(parentElm, <span class="hljs-literal">null</span>, vnode, <span class="hljs-number">0</span>, vnode.length - <span class="hljs-number">1</span>);
}
</code></pre><h2 class="heading" data-id="heading-5">sameVnode</h2>
<p>上面这些比较好理解，下面我们来看看什么情况下两个 VNode 会属于 <code>sameVnode</code> （相同的节点）呢？</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameVnode</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> (
        a.key === b.key &amp;&amp;
        a.tag === b.tag &amp;&amp;
        a.isComment === b.isComment &amp;&amp;
        (!!a.data) === (!!b.data) &amp;&amp;
        sameInputType(a, b)
    )
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameInputType</span> (<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">if</span> (a.tag !== <span class="hljs-string">'input'</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    <span class="hljs-keyword">let</span> i
    <span class="hljs-keyword">const</span> typeA = (i = a.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type
    <span class="hljs-keyword">const</span> typeB = (i = b.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type
    <span class="hljs-keyword">return</span> typeA === typeB
}
</code></pre><p><code>sameVnode</code> 其实很简单，只有当 <code>key</code>、 <code>tag</code>、 <code>isComment</code>（是否为注释节点）、 <code>data</code>同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改&lt;input&gt;类型，所以他们被视为不同类型）即可。</p>
<h2 class="heading" data-id="heading-6">patchVnode</h2>
<p>之前patch的过程还剩下 <code>patchVnode</code> 这个函数没有讲，这也是最复杂的一个，我们现在来看一下。因为这个函数是在符合 <code>sameVnode</code> 的条件下触发的，所以会进行「<strong>比对</strong>」。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patchVnode</span> (<span class="hljs-params">oldVnode, vnode</span>) </span>{
    <span class="hljs-keyword">if</span> (oldVnode === vnode) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) {
        vnode.elm = oldVnode.elm;
        vnode.componentInstance = oldVnode.componentInstance;
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> elm = vnode.elm = oldVnode.elm;
    <span class="hljs-keyword">const</span> oldCh = oldVnode.children;
    <span class="hljs-keyword">const</span> ch = vnode.children;

    <span class="hljs-keyword">if</span> (vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) {
            updateChildren(elm, oldCh, ch);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch) {
            <span class="hljs-keyword">if</span> (oldVnode.text) nodeOps.setTextContent(elm, <span class="hljs-string">''</span>);
            addVnodes(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.length - <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCh) {
            removeVnodes(elm, oldCh, <span class="hljs-number">0</span>, oldCh.length - <span class="hljs-number">1</span>)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.text) {
            nodeOps.setTextContent(elm, <span class="hljs-string">''</span>)
        }
    }
}
</code></pre><p>首先在新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (oldVnode === vnode) {
    <span class="hljs-keyword">return</span>;
}
</code></pre><p>下面的这种情况也比较简单，在当新老 VNode 节点都是 <code>isStatic</code>（静态的），并且 <code>key</code> 相同时，只要将 <code>componentInstance</code> 与 <code>elm</code> 从老 VNode 节点“拿过来”即可。这里的 <code>isStatic</code> 也就是前面提到过的「编译」的时候会将静态节点标记出来，这样就可以跳过比对的过程。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) {
    vnode.elm = oldVnode.elm;
    vnode.componentInstance = oldVnode.componentInstance;
    <span class="hljs-keyword">return</span>;
}
</code></pre><p>接下来，当新 VNode 节点是文本节点的时候，直接用 <code>setTextContent</code> 来设置 text，这里的 <code>nodeOps</code> 是一个适配层，根据不同平台提供不同的操作平台 DOM 的方法，实现跨平台。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (vnode.text) {
    nodeOps.setTextContent(elm, vnode.text);
}
</code></pre><p>当新 VNode 节点是非文本节点当时候，需要分几种情况。</p>
<ul>
<li><code>oldCh</code> 与 <code>ch</code> 都存在且不想同时，使用 <code>updateChildren</code> 函数来更新子节点，这个后面重点讲。</li>
<li>如果只有 <code>ch</code> 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 <code>ch</code> 批量插入插入到节点elm下。</li>
<li>同理当只有 <code>oldch</code> 存在时，说明需要将老节点通过 <code>removeVnodes</code> 全部清除。</li>
<li>最后一种情况是当只有老节点是文本节点的时候，清除其节点文本内容。</li>
</ul>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) {
    updateChildren(elm, oldCh, ch);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch) {
    <span class="hljs-keyword">if</span> (oldVnode.text) nodeOps.setTextContent(elm, <span class="hljs-string">''</span>);
    addVnodes(elm, <span class="hljs-literal">null</span>, ch, <span class="hljs-number">0</span>, ch.length - <span class="hljs-number">1</span>);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCh) {
    removeVnodes(elm, oldCh, <span class="hljs-number">0</span>, oldCh.length - <span class="hljs-number">1</span>)
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldVnode.text) {
    nodeOps.setTextContent(elm, <span class="hljs-string">''</span>)
}
</code></pre><h2 class="heading" data-id="heading-7">updateChildren</h2>
<p>接下来就要讲一下 <code>updateChildren</code> 函数了。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateChildren</span> (<span class="hljs-params">parentElm, oldCh, newCh</span>) </span>{
    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx];
    <span class="hljs-keyword">let</span> newEndIdx = newCh.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx];
    <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm;

    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
        <span class="hljs-keyword">if</span> (!oldStartVnode) {
            oldStartVnode = oldCh[++oldStartIdx];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!oldEndVnode) {
            oldEndVnode = oldCh[--oldEndIdx];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) {
            patchVnode(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) {
            patchVnode(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) {
            patchVnode(oldStartVnode, newEndVnode);
            nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) {
            patchVnode(oldEndVnode, newStartVnode);
            nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">let</span> elmToMove = oldCh[idxInOld];
            <span class="hljs-keyword">if</span> (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
            idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">if</span> (!idxInOld) {
                createElm(newStartVnode, parentElm);
                newStartVnode = newCh[++newStartIdx];
            } <span class="hljs-keyword">else</span> {
                elmToMove = oldCh[idxInOld];
                <span class="hljs-keyword">if</span> (sameVnode(elmToMove, newStartVnode)) {
                    patchVnode(elmToMove, newStartVnode);
                    oldCh[idxInOld] = <span class="hljs-literal">undefined</span>;
                    nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                } <span class="hljs-keyword">else</span> {
                    createElm(newStartVnode, parentElm);
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
    }

    <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) {
        refElm = (newCh[newEndIdx + <span class="hljs-number">1</span>]) ? newCh[newEndIdx + <span class="hljs-number">1</span>].elm : <span class="hljs-literal">null</span>;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
}
</code></pre><p>看到代码那么多先不要着急，我们还是一点一点地讲解。</p>
<p>首先我们定义 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 分别是新老两个 VNode 的两边的索引，同时 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 分别指向这几个索引对应的 VNode 节点。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b707df4902029?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="885" data-height="397" src="https://user-gold-cdn.xitu.io/2018/1/2/160b707df4902029?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>接下来是一个 <code>while</code> 循环，在这过程中，<code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 会逐渐向中间靠拢。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) 
</code></pre><p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b70ecf5967f0a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="864" data-height="428" src="https://user-gold-cdn.xitu.io/2018/1/2/160b70ecf5967f0a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>首先当 <code>oldStartVnode</code> 或者 <code>oldEndVnode</code> 不存在的时候，<code>oldStartIdx</code> 与 <code>oldEndIdx</code> 继续向中间靠拢，并更新对应的 <code>oldStartVnode</code> 与 <code>oldEndVnode</code> 的指向（注：下面讲到的 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 移动都会伴随着 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 的指向的变化，之后的部分只会讲 <code>Idx</code> 的移动）。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (!oldStartVnode) {
    oldStartVnode = oldCh[++oldStartIdx];
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!oldEndVnode) {
    oldEndVnode = oldCh[--oldEndIdx];
}
</code></pre><p>接下来这一块，是将 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 两两比对的过程，一共会出现 2*2=4 种情况。</p>
<pre><code class="hljs javascript" lang="javascript"> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) {
    patchVnode(oldStartVnode, newStartVnode);
    oldStartVnode = oldCh[++oldStartIdx];
    newStartVnode = newCh[++newStartIdx];
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) {
    patchVnode(oldEndVnode, newEndVnode);
    oldEndVnode = oldCh[--oldEndIdx];
    newEndVnode = newCh[--newEndIdx];
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) {
    patchVnode(oldStartVnode, newEndVnode);
    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
    oldStartVnode = oldCh[++oldStartIdx];
    newEndVnode = newCh[--newEndIdx];
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) {
    patchVnode(oldEndVnode, newStartVnode);
    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
    oldEndVnode = oldCh[--oldEndIdx];
    newStartVnode = newCh[++newStartIdx];
} 
</code></pre><p>首先是 <code>oldStartVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接进行 <code>patchVnode</code>，同时 <code>oldStartIdx</code> 与 <code>newStartIdx</code> 向后移动一位。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b71f5a48631f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="618" data-height="251" src="https://user-gold-cdn.xitu.io/2018/1/2/160b71f5a48631f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>其次是 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code>，也就是两个 VNode 的结尾是相同的 VNode，同样进行 <code>patchVnode</code> 操作并将 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 向前移动一位。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b7228b9ecb23a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="753" data-height="235" src="https://user-gold-cdn.xitu.io/2018/1/2/160b7228b9ecb23a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>接下来是两种交叉的情况。</p>
<p>先是 <code>oldStartVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code> 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 <code>oldStartVnode.elm</code> 这个节点直接移动到 <code>oldEndVnode.elm</code> 这个节点的后面即可。然后 <code>oldStartIdx</code> 向后移动一位，<code>newEndIdx</code> 向前移动一位。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b723af0fd706a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="1280" data-height="644" src="https://user-gold-cdn.xitu.io/2018/1/2/160b723af0fd706a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>同理，<code>oldEndVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 <code>oldEndVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 前面。同样的，<code>oldEndIdx</code> 向前移动一位，<code>newStartIdx</code> 向后移动一位。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b72ae720954cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="810" data-height="432" src="https://user-gold-cdn.xitu.io/2018/1/2/160b72ae720954cd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>最后是当以上情况都不符合的时候，这种情况怎么处理呢？</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">let</span> elmToMove = oldCh[idxInOld];
    <span class="hljs-keyword">if</span> (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
    idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (!idxInOld) {
        createElm(newStartVnode, parentElm);
        newStartVnode = newCh[++newStartIdx];
    } <span class="hljs-keyword">else</span> {
        elmToMove = oldCh[idxInOld];
        <span class="hljs-keyword">if</span> (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode);
            oldCh[idxInOld] = <span class="hljs-literal">undefined</span>;
            nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
        } <span class="hljs-keyword">else</span> {
            createElm(newStartVnode, parentElm);
            newStartVnode = newCh[++newStartIdx];
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createKeyToOldIdx</span> (<span class="hljs-params">children, beginIdx, endIdx</span>) </span>{
    <span class="hljs-keyword">let</span> i, key
    <span class="hljs-keyword">const</span> map = {}
    <span class="hljs-keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) {
        key = children[i].key
        <span class="hljs-keyword">if</span> (isDef(key)) map[key] = i
    }
    <span class="hljs-keyword">return</span> map
}
</code></pre><p><code>createKeyToOldIdx</code> 的作用是产生 <code>key</code> 与 <code>index</code> 索引对应的一个 map 表。比如说：</p>
<pre><code class="hljs json" lang="json">[
    {xx: xx, key: 'key0'},
    {xx: xx, key: 'key1'}, 
    {xx: xx, key: 'key2'}
]
</code></pre><p>在经过 <code>createKeyToOldIdx</code> 转化以后会变成：</p>
<pre><code class="hljs json" lang="json">{
    key0: 0, 
    key1: 1, 
    key2: 2
}
</code></pre><p>我们可以根据某一个 key 的值，快速地从 <code>oldKeyToIdx</code>（<code>createKeyToOldIdx</code> 的返回值）中获取相同 key 的节点的索引 <code>idxInOld</code>，然后找到相同的节点。</p>
<p>如果没有找到相同的节点，则通过 <code>createElm</code> 创建一个新节点，并将 <code>newStartIdx</code> 向后移动一位。</p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (!idxInOld) {
    createElm(newStartVnode, parentElm);
    newStartVnode = newCh[++newStartIdx];
}
</code></pre><p>否则如果找到了节点，同时它符合 <code>sameVnode</code>，则将这两个节点进行 <code>patchVnode</code>，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点key相同可以检测出来提示已有重复的 key ），同时将 <code>newStartVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 的前面。同理，<code>newStartIdx</code> 往后移动一位。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b73aa8f758342?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="750" data-height="373" src="https://user-gold-cdn.xitu.io/2018/1/2/160b73aa8f758342?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">else</span> {
    elmToMove = oldCh[idxInOld];
    <span class="hljs-keyword">if</span> (sameVnode(elmToMove, newStartVnode)) {
        patchVnode(elmToMove, newStartVnode);
        oldCh[idxInOld] = <span class="hljs-literal">undefined</span>;
        nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
        newStartVnode = newCh[++newStartIdx];
    }
}
</code></pre><p>如果不符合 <code>sameVnode</code>，只能创建一个新节点插入到 <code>parentElm</code> 的子节点中，<code>newStartIdx</code> 往后移动一位。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b73f50ed43932?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="927" data-height="462" src="https://user-gold-cdn.xitu.io/2018/1/2/160b73f50ed43932?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">else</span> {
    createElm(newStartVnode, parentElm);
    newStartVnode = newCh[++newStartIdx];
}
</code></pre><p>最后一步就很容易啦，当 <code>while</code> 循环结束以后，如果 <code>oldStartIdx &gt; oldEndIdx</code>，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 <code>addVnodes</code> 将这些节点插入即可。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b7457cae26687?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="784" data-height="373" src="https://user-gold-cdn.xitu.io/2018/1/2/160b7457cae26687?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<p>同理，如果满足 <code>newStartIdx &gt; newEndIdx</code> 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 <code>removeVnodes</code> 批量删除即可。</p>
<p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2018/1/2/160b744a2c07257d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="836" data-height="367" src="https://user-gold-cdn.xitu.io/2018/1/2/160b744a2c07257d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><figcaption></figcaption></figure><p></p>
<pre><code class="hljs javascript" lang="javascript"><span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) {
    refElm = (newCh[newEndIdx + <span class="hljs-number">1</span>]) ? newCh[newEndIdx + <span class="hljs-number">1</span>].elm : <span class="hljs-literal">null</span>;
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
}
</code></pre><p>到这里，比对的核心实现已经讲完了，这部分比较复杂，不过仔细地梳理一下比对的过程，相信一定能够理解得更加透彻的。</p>
<p>注：本节代码参考<a target="_blank" href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fanswershuto%2FVueDemo%2Fblob%2Fmaster%2F%25E3%2580%258A%25E6%2595%25B0%25E6%258D%25AE%25E7%258A%25B6%25E6%2580%2581%25E6%259B%25B4%25E6%2596%25B0%25E6%2597%25B6%25E7%259A%2584%25E5%25B7%25AE%25E5%25BC%2582%2520diff%2520%25E5%258F%258A%2520patch%2520%25E6%259C%25BA%25E5%2588%25B6%25E3%2580%258B.js" rel="nofollow noopener noreferrer">《数据状态更新时的差异 diff 及 patch 机制》</a>。</p>
</div><section data-v-41acfafa="" class="book-comments"><div data-v-41acfafa="" class="box-title">留言</div><div data-v-41acfafa="" class="comment-box"><div data-v-efcd2e56="" data-v-41acfafa="" class="comment-form comment-form" id="comment"><div data-v-b2db8566="" data-v-1b9df826="" data-v-efcd2e56="" data-src="https://avatars1.githubusercontent.com/u/25916562?v=4" class="lazy avatar avatar loaded" title="" style="background-image: url(&quot;https://avatars1.githubusercontent.com/u/25916562?v=4&quot;);"></div><textarea data-v-efcd2e56="" placeholder="评论将在后台进行审核，审核通过后对所有人可见" class="content-input" style="overflow: hidden; overflow-wrap: break-word; height: 60px;"></textarea><div data-v-efcd2e56="" class="action-box" style="display: none;"><div data-v-54e3f196="" data-v-efcd2e56="" class="image-uploader image-uploader" style="display: none;"><input data-v-54e3f196="" type="file" class="input"><button data-v-54e3f196="" class="upload-btn"><i data-v-54e3f196="" class="icon ion-image"></i><span data-v-54e3f196="">上传图片</span></button></div><div data-v-efcd2e56="" class="submit-box"><span data-v-efcd2e56="" class="submit-text">Ctrl or ⌘ + Enter</span><button data-v-efcd2e56="" class="submit-btn">评论</button></div></div><!----></div></div><ul data-v-51163f89="" data-v-41acfafa="" st:block="commentList" class="comment-list comment-list"><!----></ul></section></div></div><!----><!----></body></html>